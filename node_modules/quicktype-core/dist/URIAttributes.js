"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const URI = require("urijs");
const path = require("path");
const TypeAttributes_1 = require("./TypeAttributes");
const collection_utils_1 = require("collection-utils");
const Support_1 = require("./support/Support");
const util_1 = require("util");
const protocolsSchemaProperty = "qt-uri-protocols";
const extensionsSchemaProperty = "qt-uri-extensions";
class URITypeAttributeKind extends TypeAttributes_1.TypeAttributeKind {
    constructor() {
        super("uriAttributes");
    }
    combine(attrs) {
        const schemaSets = attrs.map(a => a.protocols);
        const extensionSets = attrs.map(a => a.extensions);
        return {
            protocols: collection_utils_1.setUnionManyInto(new Set(), schemaSets),
            extensions: collection_utils_1.setUnionManyInto(new Set(), extensionSets)
        };
    }
    makeInferred(_) {
        return undefined;
    }
    addToSchema(schema, t, attrs) {
        if (t.kind !== "string")
            return;
        if (attrs.protocols.size > 0) {
            schema[protocolsSchemaProperty] = Array.from(attrs.protocols).sort();
        }
        if (attrs.extensions.size > 0) {
            schema[extensionsSchemaProperty] = Array.from(attrs.extensions).sort();
        }
    }
}
exports.uriTypeAttributeKind = new URITypeAttributeKind();
function uriInferenceAttributesProducer(s) {
    try {
        const uri = URI.parse(s);
        const extension = path.extname(uri.path).toLowerCase();
        const extensions = extension === "" ? [] : [extension];
        return exports.uriTypeAttributeKind.makeAttributes({
            protocols: new Set([uri.protocol.toLowerCase()]),
            extensions: new Set(extensions)
        });
    }
    catch (_a) {
        return TypeAttributes_1.emptyTypeAttributes;
    }
}
exports.uriInferenceAttributesProducer = uriInferenceAttributesProducer;
function uriSchemaAttributesProducer(schema, _ref, types) {
    if (!(typeof schema === "object"))
        return undefined;
    if (!types.has("string"))
        return undefined;
    let protocols;
    const maybeProtocols = schema[protocolsSchemaProperty];
    if (maybeProtocols !== undefined) {
        protocols = new Set(Support_1.checkArray(maybeProtocols, util_1.isString));
    }
    else {
        protocols = new Set();
    }
    let extensions;
    const maybeExtensions = schema[extensionsSchemaProperty];
    if (maybeExtensions !== undefined) {
        extensions = new Set(Support_1.checkArray(maybeExtensions, util_1.isString));
    }
    else {
        extensions = new Set();
    }
    if (protocols.size === 0 && extensions.size === 0)
        return undefined;
    return { forString: exports.uriTypeAttributeKind.makeAttributes({ protocols, extensions }) };
}
exports.uriSchemaAttributesProducer = uriSchemaAttributesProducer;
